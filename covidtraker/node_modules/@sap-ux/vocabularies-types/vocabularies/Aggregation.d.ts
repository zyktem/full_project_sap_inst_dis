import * as Core from "./Core";
import * as Capabilities from "./Capabilities";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import ComplexType = Edm.RecordComplexType;
/**
  This entity set or collection supports the `$apply` system query option
*/
export type ApplySupported = {
    term: AggregationAnnotationTerms.ApplySupported;
} & AnnotationTerm<ApplySupportedTypeTypes>;
/**
  Default support of the `$apply` system query option for all collection-valued resources in the container
*/
export type ApplySupportedDefaults = {
    term: AggregationAnnotationTerms.ApplySupportedDefaults;
} & AnnotationTerm<ApplySupportedBaseTypes>;
export type ApplySupportedBase = ComplexType & {
    $Type: AggregationAnnotationTypes.ApplySupportedBase;
    /**
        Transformations that can be used in `$apply`
    */
    Transformations: PropertyAnnotationValue<Edm.String[]>;
    /**
        Qualified names of custom aggregation methods that can be used in `aggregate(...with...)`
    */
    CustomAggregationMethods: PropertyAnnotationValue<Edm.String[]>;
    /**
        The service supports rollup hierarchies in a `groupby` transformation
    */
    Rollup: RollupType;
};
export type ApplySupportedType = ComplexType & Omit<ApplySupportedBase, '$Type'> & {
    $Type: AggregationAnnotationTypes.ApplySupportedType;
    /**
        Only properties marked as `Groupable` can be used in the `groupby` transformation, and only those marked as `Aggregatable` can be used in the  `aggregate` transformation
    */
    PropertyRestrictions: PropertyAnnotationValue<Edm.Boolean>;
    /**
        A non-empty collection indicates that only the listed properties of the annotated target are supported by the `groupby` transformation
    */
    GroupableProperties: Edm.PropertyPath[];
    /**
        A non-empty collection indicates that only the listed properties of the annotated target can be used in the `aggregate` transformation, optionally restricted to the specified aggregation methods
    */
    AggregatableProperties: AggregatablePropertyTypeTypes[];
};
export type AggregatablePropertyType = ComplexType & {
    $Type: AggregationAnnotationTypes.AggregatablePropertyType;
    /**
        Aggregatable property
    */
    Property: Edm.PropertyPath;
    /**
        Standard and custom aggregation methods that can be applied to the property. If omitted, all aggregation methods can be applied
    */
    SupportedAggregationMethods: AggregationMethod[];
    /**
        Recommended method for aggregating values of the property
    */
    RecommendedAggregationMethod?: AggregationMethod;
};
/**
  Standard or custom aggregation method
*/
export type AggregationMethod = Edm.String;
/**
  The number of `rollup` or `rollupall` operators allowed in a `groupby` transformation
*/
export declare const enum RollupType {
    /**
    No support for `rollup` or `rollupall`
    */
    /**
    undefined
    */
    None = "Aggregation.RollupType/None",
    /**
    Only one `rollup` or `rollupall` operator per `groupby`
    */
    /**
    undefined
    */
    SingleHierarchy = "Aggregation.RollupType/SingleHierarchy",
    /**
    Full support for `rollup` and `rollupall`
    */
    /**
    undefined
    */
    MultipleHierarchies = "Aggregation.RollupType/MultipleHierarchies"
}
/**
  This property can be used in the `groupby` transformation
*/
export type Groupable = {
    term: AggregationAnnotationTerms.Groupable;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  This property can be used in the `aggregate` transformation
*/
export type Aggregatable = {
    term: AggregationAnnotationTerms.Aggregatable;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Dynamic property that can be used in the `aggregate` transformation
*/
export type CustomAggregate = {
    term: AggregationAnnotationTerms.CustomAggregate;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  The annotated property or custom aggregate is only well-defined in the context of these properties
*/
export type ContextDefiningProperties = {
    term: AggregationAnnotationTerms.ContextDefiningProperties;
} & AnnotationTerm<Edm.PropertyPath[]>;
/**
  Defines a leveled hierarchy by defining an ordered list of properties in the hierarchy
*/
export type LeveledHierarchy = {
    term: AggregationAnnotationTerms.LeveledHierarchy;
} & AnnotationTerm<Edm.PropertyPath[]>;
/**
  Defines a recursive hierarchy.
*/
export type RecursiveHierarchy = {
    term: AggregationAnnotationTerms.RecursiveHierarchy;
} & AnnotationTerm<RecursiveHierarchyTypeTypes>;
export type RecursiveHierarchyType = ComplexType & {
    $Type: AggregationAnnotationTypes.RecursiveHierarchyType;
    /**
        Property holding the hierarchy node value
    */
    NodeProperty: Edm.PropertyPath;
    /**
        Property for navigating to the parent node
    */
    ParentNavigationProperty: Edm.NavigationPropertyPath;
    /**
        Property holding the number of edges between the node and the root node
    */
    DistanceFromRootProperty?: Edm.PropertyPath;
    /**
        Property indicating whether the node is a leaf of the hierarchy
    */
    IsLeafProperty?: Edm.PropertyPath;
};
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is the root of the hierarchy
*/
export type isroot = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance
*/
export type isdescendant = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType, MaxDistance: Edm.Int16) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance
*/
export type isancestor = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType, MaxDistance: Edm.Int16) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has the same parent node as the specified node
*/
export type issibling = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has no descendants
*/
export type isleaf = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;
/**
  This action or function is available on aggregated entities if the `RequiredProperties` are still defined
*/
export type AvailableOnAggregates = {
    term: AggregationAnnotationTerms.AvailableOnAggregates;
} & AnnotationTerm<AvailableOnAggregatesTypeTypes>;
export type AvailableOnAggregatesType = ComplexType & {
    $Type: AggregationAnnotationTypes.AvailableOnAggregatesType;
    /**
        Properties required to apply this action or function
    */
    RequiredProperties: Edm.PropertyPath[];
};
/**
  Aggregation capabilities on a navigation path
*/
export type NavigationPropertyAggregationCapabilities = ComplexType & Omit<Capabilities.NavigationPropertyRestriction, '$Type'> & {
    $Type: AggregationAnnotationTypes.NavigationPropertyAggregationCapabilities;
    /**
        Support for `$apply`
    */
    ApplySupported?: ApplySupportedTypeTypes;
    /**
        Supported custom aggregates
    */
    CustomAggregates: CustomAggregateTypeTypes[];
};
export type CustomAggregateType = ComplexType & {
    $Type: AggregationAnnotationTypes.CustomAggregateType;
    /**
        Name of the dynamic property that can be used in the `aggregate` transformation
    */
    Name: PropertyAnnotationValue<Edm.String>;
    /**
        Qualified name of a primitive type. The aggregated value will be of that type
    */
    Type: PropertyAnnotationValue<Edm.String>;
};
export declare const enum AggregationAnnotationTerms {
    ApplySupported = "Org.OData.Aggregation.V1.ApplySupported",
    ApplySupportedDefaults = "Org.OData.Aggregation.V1.ApplySupportedDefaults",
    Groupable = "Org.OData.Aggregation.V1.Groupable",
    Aggregatable = "Org.OData.Aggregation.V1.Aggregatable",
    CustomAggregate = "Org.OData.Aggregation.V1.CustomAggregate",
    ContextDefiningProperties = "Org.OData.Aggregation.V1.ContextDefiningProperties",
    LeveledHierarchy = "Org.OData.Aggregation.V1.LeveledHierarchy",
    RecursiveHierarchy = "Org.OData.Aggregation.V1.RecursiveHierarchy",
    AvailableOnAggregates = "Org.OData.Aggregation.V1.AvailableOnAggregates"
}
export declare const enum AggregationAnnotationTypes {
    ApplySupportedBase = "Org.OData.Aggregation.V1.ApplySupportedBase",
    ApplySupportedType = "Org.OData.Aggregation.V1.ApplySupportedType",
    AggregatablePropertyType = "Org.OData.Aggregation.V1.AggregatablePropertyType",
    RecursiveHierarchyType = "Org.OData.Aggregation.V1.RecursiveHierarchyType",
    AvailableOnAggregatesType = "Org.OData.Aggregation.V1.AvailableOnAggregatesType",
    NavigationPropertyAggregationCapabilities = "Org.OData.Aggregation.V1.NavigationPropertyAggregationCapabilities",
    CustomAggregateType = "Org.OData.Aggregation.V1.CustomAggregateType"
}
export type ApplySupportedBaseTypes = ApplySupportedBase | ApplySupportedTypeTypes;
export type ApplySupportedTypeTypes = ApplySupportedType;
export type AggregatablePropertyTypeTypes = AggregatablePropertyType;
export type RecursiveHierarchyTypeTypes = RecursiveHierarchyType;
export type AvailableOnAggregatesTypeTypes = AvailableOnAggregatesType;
export type NavigationPropertyAggregationCapabilitiesTypes = NavigationPropertyAggregationCapabilities;
export type NavigationPropertyRestrictionTypes = Capabilities.NavigationPropertyRestriction | NavigationPropertyAggregationCapabilitiesTypes;
export type CustomAggregateTypeTypes = CustomAggregateType;
