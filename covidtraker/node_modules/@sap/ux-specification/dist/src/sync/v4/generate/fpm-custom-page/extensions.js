"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleExtensions = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const utils_1 = require("../../../common/utils");
const utils_2 = require("../../../common/generate/utils");
const utils_3 = require("./utils");
const utils_4 = require("../../utils/utils");
const ANNOTATION_PREFIX_MAP = new Map([['filterFields', 'SelectionField::']]);
const PLACEMENT_PROPERTIES = {
    anchor: 'anchor',
    placement: 'placement',
    key: 'key'
};
/**
 * Method checks if passed schema definition is custom extension.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object which contains custom extensions and annotation elements.
 * @param {SchemaDefinition} appSchema Full app schema.
 * @returns {string} Added property name.
 */
function isCustomExtensionSchema(schema, appSchema) {
    if (typeof schema.additionalProperties === 'object' && schema.additionalProperties.$ref) {
        const definition = appSchema.definitions?.[(0, utils_1.getDefinitionKey)(schema.additionalProperties.$ref)];
        const additionalProperties = typeof definition === 'object' ? definition.properties || {} : {};
        return (PLACEMENT_PROPERTIES.anchor in additionalProperties &&
            PLACEMENT_PROPERTIES.placement in additionalProperties);
    }
    return false;
}
/**
 * Method returns annotation prefix for passed macro node name.
 * @param {string} nodeName Macros node name.
 * @returns {string} Annotation prefix.
 */
function getAnnotationPrefix(nodeName) {
    return ANNOTATION_PREFIX_MAP.get(nodeName) || '';
}
/**
 * Method returns proxy extension object by parsing XML node.
 * Proxy object is required to be able to reuse 'utils.addExtensionToArray' method to recalculate order of annotation and custom extensions.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object which contains custom extensions and annotation elements.
 * @param {string} property Custom extension key in schema's properties.
 * @returns {ExtensionData} Proxy extension object.
 */
function getExtensionData(node, schema, property) {
    const schemaNode = schema.properties[property];
    const annotationPrefix = getAnnotationPrefix(node.name);
    // Custom extension node
    const xmlPath = schemaNode.metadata.path;
    const xmlExtension = node.subElements[xmlPath[xmlPath.length - 1].index];
    const key = (0, utils_3.getAttribute)(xmlExtension, PLACEMENT_PROPERTIES.key) || property;
    const anchor = (0, utils_3.getAttribute)(xmlExtension, PLACEMENT_PROPERTIES.anchor);
    const placement = (0, utils_3.getAttribute)(xmlExtension, PLACEMENT_PROPERTIES.placement) || ux_specification_types_1.v4.Placement.After;
    const annotationAnchor = `${annotationPrefix}${anchor}`;
    const extension = {
        position: {
            anchor: annotationAnchor in schema.properties ? annotationAnchor : anchor,
            placement
        }
    };
    return { key, extension };
}
/**
 * Method updates 'propertyIndex' for passed schema's properties.
 * Method prepares proxy objects and reuses 'utils.addExtensionToArray' method to recalculate order of annotation and custom extensions.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object which contains custom extensions and annotation elements.
 */
function updatePropertyIndices(node, schema) {
    // Reuse "addExtensionToArray" method for calculating extensions position as it is done for manifest based extensions
    // Logic requires to create 2 proxy objects to be able to reuse same logic
    // Custom extension entries
    const extensions = {};
    // Annotation entries
    const sortedExtensionsArray = [];
    // Custom extension mapping between schema property key and extension key in xml
    const extensionSchemaKeyMap = {};
    // Populate annotation and custom extension entries
    for (const property in schema.properties) {
        const schemaNode = schema.properties[property];
        if ('metadata' in schemaNode) {
            // Custom extension node
            const { extension, key } = getExtensionData(node, schema, property);
            extensions[key] = extension;
            // Mapping between extension key in xml and key in schema
            extensionSchemaKeyMap[key] = property;
        }
        else {
            // Annotation based node
            sortedExtensionsArray.push([property, schemaNode]);
        }
    }
    // Reuse method to calculate order
    (0, utils_4.addExtensionToArray)(extensions, sortedExtensionsArray, '', 'position');
    // Apply order to 'propertyIndex' properties in schema
    for (let i = 0; i < sortedExtensionsArray.length; i++) {
        const key = sortedExtensionsArray[i][0];
        let schemaNode = schema.properties[key];
        if (sortedExtensionsArray[i][1].$ref === '#/definitions/' && key in extensionSchemaKeyMap) {
            // Entry of custom extension
            schemaNode = schema.properties[extensionSchemaKeyMap[key]];
        }
        if (schemaNode) {
            // Update index to affect ordering
            schemaNode.propertyIndex = i;
        }
    }
}
/**
 * Method refreshes custom extension schema's 'anchor' property with 'oneOf' enum entires.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object which contains custom extensions and annotation elements.
 * @param {SchemaDefinition} appSchema Full app schema.
 */
function applyEnumsForAnchors(node, schema, appSchema) {
    const annotationPrefix = getAnnotationPrefix(node.name);
    for (const name in schema.properties) {
        const anchorProperty = 'anchor';
        const property = schema.properties[name];
        if (!property.metadata) {
            continue;
        }
        (0, utils_2.addDescriptiveEnumDefinition)(appSchema, schema, {
            property: anchorProperty,
            schema: property
        }, {
            excludeKey: name,
            resolveDefinition: true
        });
        // Remove annotation prefix from anchor enum entries - it is difference between manifest and macros anchering
        const oneOf = property.properties?.[anchorProperty]?.oneOf || [];
        for (const entry of oneOf) {
            if (typeof entry !== 'object' || typeof entry.const !== 'string') {
                continue;
            }
            const property = schema.properties[entry.const];
            if (entry.const.startsWith(annotationPrefix)) {
                // Remove annotation prefix - it is not required for macros
                entry.const = entry.const.replace(annotationPrefix, '');
            }
            else if (property?.metadata?.path) {
                // Reference to custom extension - use key for enum value
                const index = property.metadata.path[property.metadata.path.length - 1].index;
                entry.const = (0, utils_3.getAttribute)(node.subElements[index], 'key') || entry.const;
            }
        }
    }
}
/**
 * Method handles custom extension - resolve positions and ordering.
 * Currently it handles `sap.fe.macros.FilterField`, but code is generic and can handle also other extensions - method relies on 'anchor' and 'placement' properties.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object which contains custom extensions and annotation elements.
 * @param {SchemaDefinition} appSchema Full app schema.
 */
function handleExtensions(node, schema, appSchema) {
    if (!isCustomExtensionSchema(schema, appSchema)) {
        // Schema does not support custom extensions
        return;
    }
    // Update ordering of nodes by updating 'propertyIndex' for each node
    updatePropertyIndices(node, schema);
    // Enhance anchor property to add enum
    applyEnumsForAnchors(node, schema, appSchema);
}
exports.handleExtensions = handleExtensions;
//# sourceMappingURL=extensions.js.map