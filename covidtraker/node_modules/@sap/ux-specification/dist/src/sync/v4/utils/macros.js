"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseXML = exports.traverseSchema = void 0;
const xml_js_1 = require("xml-js");
const ast_1 = require("@xml-tools/ast");
const parser_1 = require("@xml-tools/parser");
const i18next_1 = __importDefault(require("i18next"));
const utils_1 = require("../../common/utils");
const extensionLogger_1 = require("../../../extensionLogger");
/**
 * Method finds element by XML path.
 * @param {Element} element Element to look in.
 * @param {MacrosXMLPath} path XML path to search.
 * @returns {Element | undefined} Element is returned if element found by passed path.
 */
function findElementByXMLPath(element, path) {
    let currentElement = element;
    for (const subPath of path) {
        currentElement = currentElement.elements?.[subPath.index];
    }
    return currentElement;
}
/**
 * Method ensures that inner object exists for passed property name.
 * @param {object} obj Object to check and update.
 * @param {string} name Property name in object to check and update.
 * @returns {boolean} True if object created.
 */
function ensureObjectExists(obj, name) {
    if (!obj[name]) {
        obj[name] = {};
        return true;
    }
    return false;
}
/**
 * Method traverses schema together with XML element.
 * @param {TraverseData} traverseData Traverse data object.
 * @param {TraverseCallback} callback Callbck to handle export or import.
 * @returns {boolean} Is changes applied during export or import.
 */
function traverseSchema(traverseData, callback) {
    const { schema, element, contextPath, config, fullSchema } = traverseData;
    let { properties = {} } = schema;
    let differs = false;
    if (schema.$ref && !schema.properties) {
        const key = (0, utils_1.getDefinitionKey)(schema.$ref);
        const definition = fullSchema.definitions[key];
        if (typeof definition === 'object' && definition.properties) {
            properties = definition.properties;
        }
    }
    for (const name in properties) {
        const property = properties[name];
        if (typeof property !== 'object') {
            continue;
        }
        // Check if object contains "metadata" to map with XML element
        if (property['metadata']?.['path']?.length) {
            const path = property['metadata']['path'];
            const checkPath = path.slice(contextPath.length);
            const targetElement = findElementByXMLPath(element, checkPath);
            differs = ensureObjectExists(config, name) || differs;
            const contextConfig = config[name];
            differs =
                traverseSchema({
                    fullSchema: traverseData.fullSchema,
                    schema: property,
                    element: targetElement,
                    contextPath: path,
                    config: contextConfig,
                    parent: traverseData
                }, callback) || differs;
        }
        else {
            differs = callback(traverseData, property, config, name) || differs;
        }
    }
    return differs;
}
exports.traverseSchema = traverseSchema;
function parseXML(xmlFile, providePositions, logger) {
    let element;
    try {
        if (providePositions) {
            const { cst, tokenVector } = (0, parser_1.parse)(xmlFile.fileContent);
            const xmlDocument = (0, ast_1.buildAst)(cst, tokenVector);
            if (!xmlDocument.rootElement) {
                // Throw exception than invalid xml string provided
                throw new Error('Invalid XML');
            }
            element = xmlDocument;
        }
        else {
            element = (0, xml_js_1.xml2js)(xmlFile.fileContent);
        }
    }
    catch (error) {
        (0, extensionLogger_1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('XMLPARSEFAILURE', { error: (0, utils_1.getErrorMessage)(error) }),
            location: {
                path: xmlFile.dataSourceUri
            }
        });
    }
    return element;
}
exports.parseXML = parseXML;
//# sourceMappingURL=macros.js.map