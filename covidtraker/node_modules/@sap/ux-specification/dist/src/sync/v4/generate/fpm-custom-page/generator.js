"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCustomPageSchemaV4 = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const utils_1 = require("../../../common/utils");
const macros_1 = require("../../utils/macros");
const annotations_1 = require("./annotations");
const extensions_1 = require("./extensions");
const MACROS_NAMESPACE = 'sap.fe.macros';
// List of properties which should be used to describe schema view nodes
const descriptionProperties = ['id', 'key', 'title', 'text', 'label', 'header'];
/**
 * Method returns full element name by concating name and namespace.
 * @param {XMLElement} element Parsed XML element.
 * @returns {string} Full name of element including namespace.
 */
function getElementName(element) {
    const { ns, name } = element;
    if (ns) {
        return `${ns}:${name}`;
    }
    return name;
}
/**
 * Method checks if passed XML element is defined within passed namespace.
 * @param {XMLElement} element Parsed XML element.
 * @param {string} namespacePrefix Namespace prefix.
 * @returns {boolean} Is element defined within passed namespace.
 */
function isElementWithNamespace(element, namespacePrefix) {
    const { ns = '' } = element;
    if (!namespacePrefix) {
        return !ns;
    }
    else {
        return ns === namespacePrefix;
    }
}
/**
 * Method returns all dependecies defined in passed core SAPUI5 XML element.
 * @param {XMLElement} coreElement Parsed XML element.
 * @returns {UI5Depenencies} Object with dependencies.
 */
function getDependencies(coreElement) {
    const dependencies = {};
    const coreAttributes = coreElement.attributes || [];
    for (const attr of coreAttributes) {
        const { key, value } = attr;
        let accesor = '';
        const namespaceConst = 'xmlns:';
        if (key.startsWith(namespaceConst)) {
            accesor = key.substring(namespaceConst.length);
        }
        dependencies[value] = accesor;
    }
    return dependencies;
}
/**
 * Method returns description for passed view node.
 * @param {XMLElement} node Parsed XML element.
 * @param {string} name View node name.
 * @returns {string} Description for view node.
 */
function getViewNodeDescription(node, name) {
    let description = '';
    const attributes = node.attributes || [];
    for (const attributeName of descriptionProperties) {
        const attr = attributes.find((attribute) => attribute.key === attributeName);
        if (attr) {
            const prefix = attributeName === 'id' ? '#' : '';
            description = `${prefix}${attr.value}`;
            break;
        }
    }
    return description ? `${name} ${description}` : name;
}
/**
 * Method finds available name for properties in schema's properties.
 * @param {string} name Original property name.
 * @param {{ [k: string]: SchemaDefinition }} properties Object with existing properties.
 * @returns {string} Available name in properties.
 */
function findAvailableName(name, properties) {
    let availableName = name;
    let index = 2;
    while (availableName in properties) {
        availableName = `${name}${index}`;
        index++;
    }
    return availableName;
}
/**
 * Method prepares schema 'properties' for passed schema by resolving '$ref' property.
 * @param {SchemaDefinition} schema Schema node to update.
 * @param {SchemaDefinition} fullSchema Full schema object which contains definitions.
 */
function prepareSchemaProperties(schema, fullSchema) {
    schema.properties = {};
    if (schema.$ref) {
        const key = (0, utils_1.getDefinitionKey)(schema.$ref);
        const definition = fullSchema.definitions[key];
        if (typeof definition === 'object' && definition.properties) {
            schema.type = definition.type;
            schema.isViewNode = definition.isViewNode;
            schema.properties = JSON.parse(JSON.stringify(definition.properties));
        }
        delete schema.$ref;
    }
}
/**
 * Method handles attributes of xml node and stores range position to schema.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object containing properties matching to element attributes.
 * @param {SchemaDefinition} fullSchema Full schema object which contains definitions.
 */
function handleAttributes(node, schema, fullSchema) {
    if (!schema.properties) {
        prepareSchemaProperties(schema, fullSchema);
    }
    const { properties = {} } = schema;
    for (const attr of node.attributes) {
        const property = properties[attr.key];
        if (property && property.metadata) {
            property.metadata.position = attr.position;
        }
    }
}
/**
 * Method adds control or complex property to schema's properties.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object to update with new property.
 * @param {XMLParseParams} params XML parsing params.
 * @param {string} name Property name.
 * @returns {string} Added property name.
 */
function addControlToSchema(node, schema, params, name) {
    const fullSchema = params.schema;
    if (!schema.properties) {
        prepareSchemaProperties(schema, fullSchema);
    }
    const schemaProperty = schema.properties[name];
    const metadata = {
        path: params.path,
        type: schemaProperty?.metadata?.type,
        position: node.position
    };
    const objectKey = schemaProperty?.metadata?.path?.length ? findAvailableName(name, schema.properties) : name;
    let refs = [];
    if (schemaProperty?.$ref) {
        refs.push((0, utils_1.getDefinitionKey)(schemaProperty.$ref));
    }
    else {
        refs = [`${MACROS_NAMESPACE}.${name}`, `${MACROS_NAMESPACE}.table.${name}`];
    }
    let handled = false;
    for (const ref of refs) {
        const refDefinition = fullSchema.definitions?.[ref];
        if (typeof refDefinition !== 'object') {
            continue;
        }
        const description = getViewNodeDescription(node, name);
        if (!metadata.type) {
            metadata.type = refDefinition.metadata.type;
        }
        if (metadata.type === ux_specification_types_1.MacrosPropertyType.Control) {
            metadata.controlName = ref;
        }
        const newDefinition = {
            $ref: (0, utils_1.getDefinitionsRef)(ref),
            description,
            propertyIndex: params.index,
            metadata
        };
        handleAttributes(node, newDefinition, fullSchema);
        schema.properties[objectKey] = newDefinition;
        handled = true;
        // Call annotation handler
        annotations_1.annotationMacrosHandlers[ref]?.({
            ...params,
            node,
            schema: newDefinition,
            rootSchema: params.schema
        });
        break;
    }
    if (!handled) {
        if (!schemaProperty?.properties) {
            // Unknown definition
            const newDefinition = {
                properties: {},
                isViewNode: true,
                type: 'object',
                description: name,
                propertyIndex: params.index,
                metadata
            };
            schema.properties[objectKey] = newDefinition;
        }
        else {
            schemaProperty.metadata = metadata;
        }
    }
    return objectKey;
}
/**
 * Method adds property to schema's properties.
 * @param {XMLElement} node Parsed XML element.
 * @param {SchemaDefinition} schema Schema object to update with new property.
 * @param {XMLParseParams} params XML parsing params.
 * @param {string} name Property name.
 * @returns {string} Added property name.
 */
function handleXMLNode(node, schema, params) {
    const { macrosPrefix } = params;
    const parentSchema = schema.$ref ? params.schema.definitions?.[(0, utils_1.getDefinitionKey)(schema.$ref)] : schema;
    if (isElementWithNamespace(node, macrosPrefix) ||
        (typeof parentSchema === 'object' && parentSchema.properties?.[node.name])) {
        const names = node.name.split(':');
        const name = addControlToSchema(node, schema, params, names[names.length - 1]);
        // Go deeper in schema
        schema = schema.properties[name];
    }
    const { subElements = [] } = node;
    const uniqueKeys = {};
    for (let index = 0; index < subElements.length; index++) {
        const element = subElements[index];
        const isUnique = !uniqueKeys[element.name];
        uniqueKeys[element.name] = true;
        handleXMLNode(element, schema, {
            ...params,
            isUnique,
            index,
            path: [
                ...params.path,
                {
                    name: getElementName(element),
                    index
                }
            ]
        });
    }
    // Post process schema
    (0, extensions_1.handleExtensions)(node, schema, params.schema);
}
/**
 * Method generates schema for passed XML content.
 * @param {SchemaDefinition} genericSchema Generic schema of "sap.fe.macros".
 * @param {string} xmlFile Object with xml file.
 * @param {ConvertedMetadata} serviceAVT OData metadata.
 * @param {ExtensionLogger} [logger] - Logger class for logging messages.
 * @returns {SchemaDefinition} Generated schema for passed XML content.
 */
function generateCustomPageSchemaV4(genericSchema, xmlFile, serviceAVT, logger) {
    const viewDocument = (0, macros_1.parseXML)(xmlFile.file, true, logger);
    if (!viewDocument) {
        return undefined;
    }
    let schema = undefined;
    const coreElement = viewDocument.rootElement;
    const dependencies = getDependencies(coreElement);
    const macrosPrefix = dependencies[MACROS_NAMESPACE];
    if (macrosPrefix !== undefined) {
        // Macros supported
        schema = JSON.parse(JSON.stringify(genericSchema));
        const uniqueKeys = {};
        for (let index = 0; index < coreElement.subElements.length; index++) {
            const element = coreElement.subElements[index];
            const isUnique = !uniqueKeys[element.name];
            uniqueKeys[element.name] = true;
            handleXMLNode(element, schema, {
                macrosPrefix,
                schema,
                dependencies,
                index,
                isUnique,
                path: [
                    {
                        name: getElementName(element),
                        index
                    }
                ],
                serviceAVT,
                connectionContext: xmlFile.connection
            });
        }
    }
    return schema;
}
exports.generateCustomPageSchemaV4 = generateCustomPageSchemaV4;
//# sourceMappingURL=generator.js.map