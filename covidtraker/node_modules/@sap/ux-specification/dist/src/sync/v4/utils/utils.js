"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPageCustomViewFile = exports.addHeaderFooterCustomActionDefinition = exports.addCustomActionDefinition = exports.alignSchemaWithTemplateType = exports.findPageV4 = exports.addEnumForActionAnchor = exports.addFragmentEnumForAnchor = exports.addLineItemsTypeToSchema = exports.addCustomColumnDefinition = exports.addExtensionToArray = void 0;
const utils_1 = require("../../common/utils");
const StableIdHelper_1 = require("./StableIdHelper");
const common_1 = require("../../common");
const i18next_1 = __importDefault(require("i18next"));
const __1 = require("../../..");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const path_1 = require("path");
/**
 * Sort function for properties in schema definitions.
 * @param definition - definition which contains list of properties, unsorted
 * @returns - list of properties, sorted by property index
 */
function sortPropertiesRecords(definition) {
    definition = typeof definition === 'object' ? definition : {};
    function sortByPropertyIndex() {
        return ([_key1, value1], [_key2, value2]) => value1[ux_specification_types_1.SchemaTag.propertyIndex] - value2[ux_specification_types_1.SchemaTag.propertyIndex];
    }
    const unsortedObjArr = [...Object.entries(definition.properties)];
    return unsortedObjArr.sort(sortByPropertyIndex());
}
/**
 * Method receives extension object and returns title/text.
 * @param extension - custom extension object from manifest.
 * @returns Title/text of custom extension.
 */
function getExtensionText(extension) {
    return 'header' in extension ? extension.header : extension.text;
}
/**
 * Adds a custom extension to the right position of a sorted array
 * @param extension - custom extension
 * @param sortedExtensionsArray - array of all entries(annotation entries and extensions), to be enhanced
 * @param targetIndex - index of the anchor entry
 * @param extId - ID of the new custom extension
 * @param newExtensionReference - schema reference of the new extension
 */
function addExtensionToSortedArray(extension, sortedExtensionsArray, targetIndex, extId, newExtensionReference) {
    const placement = extension.position?.placement || ux_specification_types_1.v4.Placement.After;
    if (placement === ux_specification_types_1.v4.Placement.Before) {
        sortedExtensionsArray.splice(targetIndex, 0, [extId, newExtensionReference]);
    }
    else {
        sortedExtensionsArray.splice(targetIndex + 1, 0, [extId, newExtensionReference]);
    }
}
/**
 * Adds remaining custom extensions that might self-reference and were not added in previous steps
 * @param {CustomExtensions} remainingExtensions - list of custom extensions that are left for post-processing
 * @param {string} extId - current id of remaining extensions
 * @param {CustomExtension} extension - current extension of remaining custom extensions
 * @param {[string, unknown]} sortedExtArray - sorted array of annotation-based extensions, to be updated
 * @param { $ref, description, key } newCustomExt - description based on extension in manifest
 */
function addRemainingTargetByBefore(remainingExtensions, extId, extension, sortedExtArray, newCustomExt) {
    const targetRemainingIndex = Object.entries(remainingExtensions)
        .filter(([key]) => key !== extId)
        .findIndex(([_key, entry]) => entry.position?.placement === 'Before' && entry.position?.anchor === extension.position?.anchor);
    if (targetRemainingIndex === -1) {
        sortedExtArray.splice(sortedExtArray.length, 0, [extId, newCustomExt]);
        delete remainingExtensions[extId];
    }
}
/**
 * Post-processing of custom extensions that are left after the first loop of adding extensions, i.e. custom extensions referring to other custom extensions
 * @param remainingExtensions - list of custom extensions that are left for post-processing
 * @param extensionDefinitionName - custom extension definition name, different in LR and OP
 * @param sortedExtArray - sorted array of annotation-based extensions, to be updated
 * @param logger - logger for error messages
 * @param {boolean} forceAdd - add self-referencing custom extensions after other additions
 */
function adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger, forceAdd = false) {
    const initialRemaining = Object.entries(remainingExtensions).length;
    const getExtensionDetails = (extension, extId) => {
        const description = getExtensionText(extension);
        return {
            $ref: `${utils_1.DEFINITION_LINK_PREFIX}${extensionDefinitionName}`,
            description,
            keys: [{ name: ux_specification_types_1.SchemaKeyName.key, value: `${extId}` }]
        };
    };
    for (const extId in remainingExtensions) {
        const extension = remainingExtensions[extId];
        // Detect description based on extension in manifest
        const newCustomExt = getExtensionDetails(extension, extId);
        if (extension.position?.anchor && extension.position?.placement) {
            const targetIndex = sortedExtArray.findIndex((element) => element[0] === extension.position.anchor);
            if (targetIndex > -1) {
                addExtensionToSortedArray(extension, sortedExtArray, targetIndex, extId, newCustomExt);
                delete remainingExtensions[extId];
            }
            else if (extId === extension.position.anchor ||
                Object.keys(remainingExtensions).indexOf(extension.position.anchor) === -1) {
                (0, __1.log)(logger, {
                    severity: "error" /* LogSeverity.Error */,
                    message: i18next_1.default.t('INVALIDANCHOR', { id: extId, anchor: extension.position.anchor }),
                    location: {
                        path: ux_specification_types_1.MANIFESTPATH,
                        range: [ux_specification_types_1.ManifestSection.generic]
                    }
                });
                sortedExtArray.splice(sortedExtArray.length, 0, [extId, newCustomExt]);
                delete remainingExtensions[extId];
            }
            else if (forceAdd) {
                addRemainingTargetByBefore(remainingExtensions, extId, extension, sortedExtArray, newCustomExt);
            }
        }
    }
    const endRemaining = Object.entries(remainingExtensions).length;
    if (endRemaining > 0 && initialRemaining !== endRemaining) {
        adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger);
    }
    else if (endRemaining > 0) {
        adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger, true);
    }
}
/**
 * Returns anchor for extension. Priority:
 * 1. 'anchor' property in extension;
 * 2. When 'anchor' is not defined in extension and does calculation based placement and current list of extension and annotation entries.
 * @param extension - extension in manifest
 * @param sortedExtensionsArray - sorted array of annotation-based nodes, to be enhanced by extensions
 */
function getExtensionAnchor(extension, sortedExtensionsArray) {
    // Default placement is After
    const placement = extension.position?.placement || ux_specification_types_1.v4.Placement.After;
    let anchor = extension.position?.anchor;
    if (!anchor) {
        // Simulate runtime behavior - if there no anchor, then logic uses first or last annotation node
        // In some cases last extension can be previously inserted extension - in such case we still need use annotation node
        const index = placement === ux_specification_types_1.v4.Placement.Before ? 0 : sortedExtensionsArray.length - 1;
        anchor = sortedExtensionsArray[index] ? sortedExtensionsArray[index][0] : undefined;
    }
    return anchor;
}
/**
 * Preprocesses and returns list of local extension ids that needs to be skipped from addition
 * @param {CustomExtensions} localExtensions - list of extensions in manifest
 * @param {[string, unknown][]} annotationEntries - sorted array of annotation-based nodes, to be enhanced by extensions
 */
function getLocalExtensionsToSkip(localExtensions, annotationEntries) {
    // collect local extensions that has no annotation based anchor
    const ignoredIds = [];
    for (const extensionId in localExtensions) {
        const anchor = localExtensions[extensionId].position?.anchor;
        const hasAnnotationAnchor = annotationEntries.some((annotationEntry) => annotationEntry[0] === anchor);
        if (anchor && !hasAnnotationAnchor) {
            ignoredIds.push(extensionId);
        }
    }
    return ignoredIds;
}
/**
 * Adds extension at the right position of the sorted array of annotation-based nodes
 * @param extensions - list of extensions in manifest
 * @param sortedExtensionsArray - sorted array of annotation-based nodes, to be enhanced by extensions
 * @param extensionDefinitionName - extension definition name, different in LR and OP
 * @param loggeloggerr - logger for error messages
 */
function addExtensionToArray(extensions, sortedExtensionsArray, extensionDefinitionName, templatePropertyName = 'template', logger) {
    const annotationEntries = [...sortedExtensionsArray];
    const localExtensions = { ...extensions };
    const localExtensionsToSkip = getLocalExtensionsToSkip(localExtensions, annotationEntries);
    for (const extensionId in localExtensions) {
        if (localExtensionsToSkip.includes(extensionId)) {
            continue;
        }
        const extension = localExtensions[extensionId];
        if (!(templatePropertyName in extension)) {
            // Skip regular entries(columns, actions, etc.)
            delete localExtensions[extensionId];
            continue;
        }
        const newExtensionReference = {
            $ref: `${utils_1.DEFINITION_LINK_PREFIX}${extensionDefinitionName}`,
            description: getExtensionText(extension) || extensionId,
            keys: [{ name: ux_specification_types_1.SchemaKeyName.key, value: `${extensionId}` }]
        };
        const anchor = getExtensionAnchor(extension, annotationEntries);
        if (anchor) {
            const targetIndex = sortedExtensionsArray.findIndex((element) => element[0] === anchor);
            if (targetIndex > -1) {
                addExtensionToSortedArray(extension, sortedExtensionsArray, targetIndex, extensionId, newExtensionReference);
                delete localExtensions[extensionId];
            }
        }
        else {
            // Empty array - no any anchor to reference to
            sortedExtensionsArray.push([extensionId, newExtensionReference]);
            delete localExtensions[extensionId];
        }
    }
    if (Object.keys(localExtensions).length > 0) {
        //Second loop is necessary for custom columns that refer to custom columns
        adjustCustomExtReferringToCustomExt(localExtensions, extensionDefinitionName, sortedExtensionsArray, logger);
    }
    return sortedExtensionsArray;
}
exports.addExtensionToArray = addExtensionToArray;
/**
 * Common function for enhancing the LineItems definition of app schema by custom columns
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customColumnDefinitionName - custom column definition name
 * @param sectionId - identifier of the current object page section in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addCustomColumnDefinition(appSchema, v4Page, logger, customColumnDefinitionName = ux_specification_types_1.DefinitionName.CustomColumn, sectionId, sectionIdInManifest) {
    const lineItemId = sectionId || ux_specification_types_1.DefinitionName.LineItems;
    const lineItems = appSchema.definitions[lineItemId];
    if (!lineItems) {
        return;
    }
    //sort line items
    let sortedColumnsArray = sortPropertiesRecords(lineItems);
    const id = sectionIdInManifest ? sectionIdInManifest.replace(/::/g, '/') : `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
    const columns = v4Page.options?.settings?.controlConfiguration?.[id]?.['columns'];
    if (columns) {
        sortedColumnsArray = addExtensionToArray(columns, sortedColumnsArray, customColumnDefinitionName, undefined, logger);
    }
    //Adjust propertyIndex
    for (let index = 0; index < sortedColumnsArray.length; index++) {
        sortedColumnsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
    }
    const sortedColumnsAsObject = {};
    sortedColumnsArray.forEach(([key, value]) => (sortedColumnsAsObject[key] = value));
    appSchema.definitions[lineItemId].properties = sortedColumnsAsObject;
}
exports.addCustomColumnDefinition = addCustomColumnDefinition;
/**
 * Processes a LineItem record of type DataFieldForAction during app schema generation
 * @param {LineItemDataForSchema} data: structure of input data
 * @param actions - actions definition in schema, parent object
 * @param lineItemPath - annotation path to the line item
 * @param lineItemRecord - actual record of the line item collection
 * @param recordIndex - record index in the collection
 */
function addActionRecordToSchema(data, actionsDefinition, lineItemPath, lineItemRecord, recordIndex) {
    // Action but not inline action
    if (lineItemRecord.Determining !== true) {
        //no footer bar -> toolbar action
        let actionDefinitionName;
        if (data.lineItemId.startsWith(ux_specification_types_1.DefinitionName.LineItemsOfView)) {
            actionDefinitionName = ux_specification_types_1.DefinitionName.ViewToolBarAction;
        }
        else if (data.lineItemId.startsWith(ux_specification_types_1.DefinitionName.LineItems)) {
            actionDefinitionName = ux_specification_types_1.DefinitionName.ToolBarAction;
        }
        else {
            actionDefinitionName = ux_specification_types_1.DefinitionName.ObjectPageToolBarAction;
        }
        const actionId = lineItemRecord.Action.replace('/', '::');
        const description = (0, utils_1.getDataFieldDescription)(lineItemRecord, data.entityType);
        const prefix = lineItemRecord.$Type.split(`${ux_specification_types_1.UIVOCABULARY}.`)[1];
        const propertyKey = (0, StableIdHelper_1.replaceSpecialChars)(lineItemRecord.Action);
        const actionDefinition = (actionsDefinition.properties[`${prefix}::${propertyKey}`] = {
            $ref: (0, common_1.getFacetDefinitionLink)(actionDefinitionName, (0, common_1.prepareRef)(actionId)),
            description
        });
        const { key, ns } = (0, common_1.getActionKey)(lineItemRecord.Action, true);
        actionDefinition[ux_specification_types_1.SchemaTag.propertyIndex] = recordIndex;
        actionDefinition[ux_specification_types_1.SchemaTag.keys] = [{ name: ux_specification_types_1.SchemaKeyName.action, value: key }];
        if (ns) {
            actionDefinition[ux_specification_types_1.SchemaTag.target] = ns;
        }
        actionDefinition[ux_specification_types_1.SchemaTag.annotationType] = lineItemRecord.$Type;
        const action = (0, common_1.parseSchemaDefinition)(actionDefinitionName, (0, common_1.prepareRef)(actionId), data.appSchema);
        action[ux_specification_types_1.SchemaTag.annotationPath] = `${lineItemPath}/${recordIndex}`;
    }
}
/**
 * Processes a LineItem record of type DataField during app schema generation
 * @param {LineItemDataForSchema} data: structure of input data
 * @param lineItem - object comprising the line item information:
 * { lineItemRecord, lineItemId, lineItemPath }
 * @param columnDefinitionName - Schema definition name for the column
 * @param recordIndex - record index in the collection
 */
function addLineItemRecordToSchema(data, lineItem, columnDefinitionName, recordIndex) {
    const lineItemId = lineItem['lineItemId'];
    const lineItemRecord = lineItem['lineItemRecord'];
    if (lineItemRecord['Target']?.['value']) {
        const regex = `@${(0, utils_1.findAlias)(ux_specification_types_1.UIVOCABULARY, data.oDataServiceAVT)}.`;
        lineItemRecord['Target']['value'] = lineItemRecord['Target']['value'].replace(regex, '@');
    }
    const schemaKey = (0, StableIdHelper_1.getStableIdPartFromDataField)(lineItemRecord);
    if (schemaKey) {
        const properties = data.appSchema.definitions[lineItemId].properties;
        properties[schemaKey] = {
            $ref: utils_1.DEFINITION_LINK_PREFIX + columnDefinitionName,
            description: (0, utils_1.getDataFieldDescription)(lineItemRecord, data.entityType)
        };
        properties[schemaKey][ux_specification_types_1.SchemaTag.annotationType] = lineItemRecord?.$Type;
        properties[schemaKey][ux_specification_types_1.SchemaTag.annotationPath] = `${lineItem['lineItemPath']}/${recordIndex}`;
        properties[schemaKey][ux_specification_types_1.SchemaTag.propertyIndex] = recordIndex;
        if (lineItemRecord['Value']?.$target?.type) {
            properties[schemaKey][ux_specification_types_1.SchemaTag.dataType] = lineItemRecord['Value']?.$target?.type.replace('Edm.', '');
        }
        (0, common_1.addKeyToDefinition)(lineItemRecord, properties, schemaKey);
    }
}
/**
 * Adds the line item definition, columns and actions to the app schema (for the list report or an object page section comprising a table)
 * @param {LineItemDataForSchema} data: structure comprising
 * - appSchema - the app specific schema that shall get enhanced
 * - lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * - entityType - the entity type as part of the AVT ConvertedMetadata
 * - oDataServiceAVT - complete service information, as returned by Annotation Vocabularies Tool
 * - lineItemId - in case of OP the parameter must be passed to distinguish the OP tables;
 *                in case of LR or ALP 'LineItems' is passed.
 * @param columnDefinitionName - name of the column definition, i.e. TableColumn or ObjectPageTableColumn
 * @param customColumnDefinitionName - name of the custom column definition
 */
function addLineItemsTypeToSchema(data, columnDefinitionName = ux_specification_types_1.DefinitionName.TableColumn, customColumnDefinitionName = ux_specification_types_1.DefinitionName.CustomColumn, customActionDefinitionName = ux_specification_types_1.DefinitionName.CustomTableAction) {
    const { actions, lineItemPath } = (0, common_1.addCommonLineItemDefinitions)(data.appSchema, data.lineItemAnnotation, data.entityType, data.lineItemId, customColumnDefinitionName, customActionDefinitionName);
    if (!data.lineItemAnnotation) {
        return;
    }
    let i = 0;
    data.lineItemAnnotation.forEach((lineItemRecord) => {
        if ((lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */ ||
            lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* UIAnnotationTypes.DataFieldForIntentBasedNavigation */) &&
            (lineItemRecord.Inline !== true || lineItemRecord.Determining === true)) {
            addActionRecordToSchema(data, actions, lineItemPath, lineItemRecord, i);
        }
        else {
            const lineItem = { lineItemRecord, lineItemId: data.lineItemId, lineItemPath };
            const columnDefinition = lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */
                ? `${columnDefinitionName}Action`
                : columnDefinitionName;
            addLineItemRecordToSchema(data, lineItem, columnDefinition, i);
        }
        i++;
    });
}
exports.addLineItemsTypeToSchema = addLineItemsTypeToSchema;
/**
 * Adds an enum or value help to position > anchor of custom column
 * @param appSchema - app specific JSON schema
 * @param lineItemId - ID of the current line item in schema
 * @param v4Page - current page in manifest
 * @param positionName - ID of the definition of custom column position in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addFragmentEnumForAnchor(appSchema, lineItemId, v4Page, positionName = ux_specification_types_1.DefinitionName.Position, sectionIdInManifest) {
    const columns = appSchema.definitions[lineItemId]?.properties;
    const enumEntries = [];
    if (columns) {
        for (const key in columns) {
            if (key !== 'custom') {
                enumEntries.push(key);
            }
        }
    }
    const id = lineItemId !== ux_specification_types_1.DefinitionName.LineItems ? sectionIdInManifest : `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
    const columnsInManifest = v4Page.options?.settings?.controlConfiguration?.[id]?.['columns'];
    if (columnsInManifest) {
        for (const key in columnsInManifest) {
            if (enumEntries.indexOf(key) === -1) {
                enumEntries.push(key);
            }
        }
    }
    if (enumEntries.length > 0) {
        appSchema.definitions[positionName].properties['anchor']['enum'] = enumEntries;
    }
}
exports.addFragmentEnumForAnchor = addFragmentEnumForAnchor;
/**
 * Adds an enum or value help to position > anchor of custom column
 * @param appSchema - app specific JSON schema
 * @param definitionId - definition key of actions
 * @param positionName - target definition to update
 */
function addEnumForActionAnchor(appSchema, definitionId, positionName = ux_specification_types_1.DefinitionName.CustomActionPosition) {
    (0, common_1.addDescriptiveEnumDefinition)(appSchema, appSchema.definitions[definitionId], {
        definition: positionName,
        property: 'anchor'
    });
}
exports.addEnumForActionAnchor = addEnumForActionAnchor;
/**
 * Find the relevant V4 page under the routing targets of manifest,json
 * @param pages - list of all pages in manifest
 * @param pageName - search criterion: page name
 * @param entitySet - search criterion: entity set object from AVT
 * @param contextPath - search criterion: contextPath
 * @param logger - logger for messages
 * @returns the page definition in manifest (if found)
 */
function findPageV4(pages, pageName, entitySet, contextPath, logger) {
    let v4Page;
    for (const i in pages) {
        if (((contextPath && pages[i].options?.settings?.contextPath === contextPath) ||
            pages[i].options?.settings?.entitySet === entitySet?.name) &&
            (pages[i].name === pageName ||
                (pageName === ux_specification_types_1.v4.FE_TEMPLATE_V4_ALP && pages[i].name === ux_specification_types_1.v4.FE_TEMPLATE_V4_LIST_REPORT))) {
            v4Page = pages[i];
            break;
        }
    }
    if (!v4Page) {
        (0, __1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOENTITYSET', { entitySet }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.generic]
            }
        });
    }
    return v4Page;
}
exports.findPageV4 = findPageV4;
/**
 * Depending on the template type, strip down the app schema so that only the relevant views are part of it
 * @param {Definition} appSchema - app specific JSON schema, to be adjusted
 * @param {GenerateAppSchemaParameters} generateParameters - object comprising all input parameters
 * @returns the right definition name for the table in the schema
 */
function alignSchemaWithTemplateType(appSchema, generateParameters) {
    let tableDefinitionName;
    const tableDefinition = appSchema.properties[ux_specification_types_1.PropertyName.table];
    if (generateParameters.templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV4) {
        tableDefinitionName = ux_specification_types_1.DefinitionName.ALPTableView;
        delete tableDefinition.anyOf;
        tableDefinition.$ref = `${utils_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.ALPTableView}`;
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.Table];
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.LRChartView];
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.LRTableView];
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.MultiTableModeV4];
    }
    else if (generateParameters.templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV4) {
        tableDefinitionName = ux_specification_types_1.DefinitionName.Table;
        delete tableDefinition.anyOf;
        tableDefinition.$ref = `${utils_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.Table}`;
        appSchema.definitions[tableDefinitionName].properties[ux_specification_types_1.PropertyName.annotationPath][ux_specification_types_1.SchemaTag.hidden] = true;
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.ALPTableView];
        appSchema.properties[ux_specification_types_1.PropertyName.defaultPath][ux_specification_types_1.SchemaTag.hidden] = true;
    }
    return tableDefinitionName;
}
exports.alignSchemaWithTemplateType = alignSchemaWithTemplateType;
/**
 * Common function for enhancing LineItems and FieldGroups definitions of app schema by custom action definitions
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customActionDefinitionName - definition name of custom action
 * @param sectionId - identifier of the current object page section in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addCustomActionDefinition(appSchema, v4Page, logger, customActionDefinitionName = ux_specification_types_1.DefinitionName.CustomTableAction, sectionId = '', sectionIdInManifest = '') {
    const definition = appSchema.definitions[sectionId];
    if (!definition) {
        return;
    }
    // Sort existing actions
    let sortedActionsArray = sortPropertiesRecords(definition);
    let configId;
    if (sectionIdInManifest) {
        if (customActionDefinitionName.indexOf(ux_specification_types_1.DefinitionName.CustomFormActionOP) !== -1) {
            configId = sectionIdInManifest.replace(/::/g, '#');
        }
        else {
            configId = sectionIdInManifest.replace(/::/g, '/');
        }
    }
    else {
        if (customActionDefinitionName === ux_specification_types_1.DefinitionName.CustomFormActionOP) {
            configId = `@${"com.sap.vocabularies.UI.v1.FieldGroup" /* UIAnnotationTerms.FieldGroup */}`;
        }
        else {
            configId = `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
        }
    }
    const actions = v4Page.options?.settings?.controlConfiguration?.[configId]?.['actions'];
    if (actions) {
        sortedActionsArray = addExtensionToArray(actions, sortedActionsArray, customActionDefinitionName, 'press', logger);
    }
    // Adjust propertyIndex
    for (let index = 0; index < sortedActionsArray.length; index++) {
        sortedActionsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
    }
    const sortedActionsAsObject = {};
    sortedActionsArray.forEach(([key, value]) => (sortedActionsAsObject[key] = value));
    appSchema.definitions[sectionId].properties = sortedActionsAsObject;
}
exports.addCustomActionDefinition = addCustomActionDefinition;
/**
 * Common function for enhancing header and footer definitions of app schema by custom action definitions
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customActionDefinitionName - definition name of custom action
 * @param sectionId - identifier of the current object page section in schema
 */
function addHeaderFooterCustomActionDefinition(appSchema, v4Page, logger, customActionDefinitionName = ux_specification_types_1.DefinitionName.CustomHeaderActionOP, sectionId = '') {
    const definition = appSchema.definitions[sectionId];
    if (!definition) {
        return;
    }
    // Sort existing actions
    let sortedActionsArray = sortPropertiesRecords(definition);
    let actions;
    if ([ux_specification_types_1.DefinitionName.CustomHeaderAction, ux_specification_types_1.DefinitionName.CustomHeaderActionOP].includes(customActionDefinitionName)) {
        actions = v4Page.options?.settings?.content?.header?.['actions'];
    }
    else {
        actions = v4Page.options?.settings?.content?.footer?.['actions'];
    }
    if (actions) {
        sortedActionsArray = addExtensionToArray(actions, sortedActionsArray, customActionDefinitionName, 'press', logger);
    }
    // Adjust propertyIndex
    for (let index = 0; index < sortedActionsArray.length; index++) {
        sortedActionsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
    }
    const sortedActionsAsObject = {};
    sortedActionsArray.forEach(([key, value]) => (sortedActionsAsObject[key] = value));
    appSchema.definitions[sectionId].properties = sortedActionsAsObject;
}
exports.addHeaderFooterCustomActionDefinition = addHeaderFooterCustomActionDefinition;
/**
 * Method finds view XML file for passed page.
 * @param {FileData[]} files All view files.
 * @param {string} pageId Page id.
 * @param {Manifest} manifest Object from manifest.json.
 * @param {ExtensionLogger} [logger] Logger.
 * @returns {CustomPageCustomViewData | undefined} Custom page's data containing view XML file.
 */
function getPageCustomViewFile(files, pageId, manifest, logger) {
    const pages = manifest[ux_specification_types_1.ManifestSection.ui5]['routing']['targets'];
    if (!pages) {
        (0, __1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOTARGETS'),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    const page = pages[pageId];
    if (!page) {
        (0, __1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOROUTINGID', { routingId: pageId }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    // Resolve view name and app id
    let viewName = page.options?.settings?.['viewName']?.toString() || '';
    if (viewName) {
        const appId = manifest['sap.app']?.id || '';
        const type = 'view';
        const fileExtension = 'xml';
        if (viewName.startsWith(appId)) {
            // Remove app id from extension name
            viewName = viewName.replace(appId, '');
        }
        const fileParts = viewName.split('.');
        let baseName = fileParts.pop();
        baseName = `${baseName}.${type}.${fileExtension}`;
        const extPath = (0, path_1.join)(...fileParts, baseName);
        const file = files.find((file) => file.dataSourceUri.endsWith(extPath));
        if (file) {
            const settings = page.options?.settings;
            return {
                file,
                connection: {
                    contextPath: settings?.contextPath,
                    entitySet: settings?.entitySet
                }
            };
        }
    }
    return undefined;
}
exports.getPageCustomViewFile = getPageCustomViewFile;
//# sourceMappingURL=utils.js.map